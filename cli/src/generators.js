/**
 * CLAUDE.md generator module
 * Handles template loading, rendering, and file generation
 */

import { promises as fs } from 'fs';
import path from 'path';
import { promptExistingClaudeMd } from './prompts.js';

/**
 * Professional CLAUDE.md template with expert-level instructions
 */
const DEFAULT_TEMPLATE = `# CLAUDE.md

## Project Overview

This project has been configured with Claude Code using Highland AI's setup tool.
Update this section with a description of your project's purpose and main features.

## Tech Stack

Update this section with your specific technologies:
- **Language**: [Your language]
- **Framework**: [Your framework]
- **Database**: [Your database]

## Installed MCPs

{{#mcps}}
- **{{.}}**
{{/mcps}}

## MCP Usage Guide

### context7
Use for looking up current library documentation. When you need API details or examples for any library, use context7 instead of relying on training data.

### memory
Store important project decisions, patterns, and context that should persist across sessions. Use it to remember architectural choices and coding conventions.

### puppeteer
Use for browser automation, visual debugging, and taking screenshots. Great for testing web UIs and capturing visual state.

### filesystem
Use for all file operations - reading, writing, and navigating the project structure.

## Coding Conventions

Customize these for your project:

- Write clear, self-documenting code
- Use meaningful variable and function names
- Keep functions focused and small (< 50 lines)
- Add comments for complex logic only
- Handle errors explicitly

## Common Commands

Update with your project's commands:
- \`npm run dev\` - Start development server
- \`npm run build\` - Production build
- \`npm run test\` - Run tests
- \`npm run lint\` - Lint code

## Project Structure

Document your project's directory structure here.

## Important Notes

Add any critical information Claude should know about your project.

---
*Generated by Highland AI Claude Setup Tool*
*Customize this file to improve Claude's understanding of your project.*
`;

/**
 * Framework-specific templates with professional instructions
 */
const TEMPLATES = {
  default: DEFAULT_TEMPLATE,
  
  nextjs: `# CLAUDE.md

## Project Overview

Next.js 14+ application using App Router. Update with your project's specific purpose.

## Tech Stack

- **Framework**: Next.js 14+ (App Router)
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS
- **Database**: [Update with your database]
- **Deployment**: Vercel

## Installed MCPs

{{#mcps}}
- **{{.}}**
{{/mcps}}

## Project Structure

\`\`\`
app/           # App Router pages and layouts
  api/         # API route handlers
  (routes)/    # Route groups
components/    # Reusable React components
lib/           # Utilities and configurations
types/         # TypeScript type definitions
\`\`\`

## Coding Conventions

### Components
- Use Server Components by default (no directive needed)
- Add \`'use client'\` only when needed (interactivity, hooks, browser APIs)
- Prefer named exports over default exports
- Props interface above component definition

### TypeScript
- Strict mode enabled - no \`any\` types
- Use interfaces for object shapes
- Explicit return types for functions

### Styling
- Use Tailwind utility classes
- No inline styles or CSS modules
- Use \`cn()\` utility for conditional classes

### Data Fetching
- Server Components: fetch directly in component
- Client Components: use React Query or SWR
- API Routes: for mutations and external APIs

## Common Commands

- \`npm run dev\` - Start dev server (localhost:3000)
- \`npm run build\` - Production build
- \`npm run lint\` - ESLint check
- \`npx tsc --noEmit\` - TypeScript check

## Important Patterns

### API Routes
\`\`\`typescript
// app/api/example/route.ts
import { NextResponse } from 'next/server';

export async function GET() {
  return NextResponse.json({ data: [] });
}
\`\`\`

### Loading States
Create \`loading.tsx\` in route folders for automatic loading UI.

### Error Handling
Create \`error.tsx\` (client component) for error boundaries.

---
*Generated by Highland AI Claude Setup Tool*
`,

  'python-ml': `# CLAUDE.md

## Project Overview

Python ML/AI project. Update with your specific model/pipeline purpose.

## Tech Stack

- **Language**: Python 3.10+
- **Package Manager**: pip / poetry
- **ML Framework**: [PyTorch/TensorFlow/scikit-learn]
- **Data**: pandas, numpy
- **Experiment Tracking**: [MLflow/W&B/none]

## Installed MCPs

{{#mcps}}
- **{{.}}**
{{/mcps}}

## Project Structure

\`\`\`
src/
  data/        # Data loading and preprocessing
  models/      # Model definitions
  training/    # Training loops
  evaluation/  # Metrics and evaluation
notebooks/     # Jupyter notebooks (exploration only)
data/          # Raw and processed data (gitignored)
models/        # Saved checkpoints (gitignored)
tests/         # Unit tests
\`\`\`

## Coding Conventions

### Type Hints
Always use type hints for function signatures:
\`\`\`python
def preprocess(data: np.ndarray, normalize: bool = True) -> np.ndarray:
    ...
\`\`\`

### Configuration
Use dataclasses for configs:
\`\`\`python
@dataclass
class TrainingConfig:
    learning_rate: float = 0.001
    batch_size: int = 32
\`\`\`

### Reproducibility
Always set random seeds:
\`\`\`python
random.seed(42)
np.random.seed(42)
torch.manual_seed(42)
\`\`\`

### Documentation
Use docstrings for all functions with Args, Returns, Raises.

## Common Commands

- \`python -m venv venv\` - Create virtual environment
- \`pip install -r requirements.txt\` - Install dependencies
- \`python src/train.py\` - Run training
- \`pytest tests/\` - Run tests

## Important Notes

- Keep notebooks for exploration, scripts for production
- Version control data and model artifacts
- Log all experiments systematically

---
*Generated by Highland AI Claude Setup Tool*
`,

  generic: DEFAULT_TEMPLATE
};

/**
 * Simple mustache-like template renderer
 * @param {string} template
 * @param {object} context
 * @returns {string}
 */
export function renderTemplate(template, context) {
  let result = template;
  
  // Handle arrays with {{#key}}...{{/key}} and {{^key}}...{{/key}}
  for (const [key, value] of Object.entries(context)) {
    if (Array.isArray(value)) {
      // Positive section (has items)
      const sectionRegex = new RegExp(`\\{\\{#${key}\\}\\}([\\s\\S]*?)\\{\\{/${key}\\}\\}`, 'g');
      result = result.replace(sectionRegex, (match, content) => {
        if (value.length === 0) return '';
        // Use function replacement to avoid $ being interpreted as special replacement pattern
        return value.map(item => content.replace(/\{\{\.\}\}/g, () => item)).join('');
      });
      
      // Negative section (no items)
      const negativeRegex = new RegExp(`\\{\\{\\^${key}\\}\\}([\\s\\S]*?)\\{\\{/${key}\\}\\}`, 'g');
      result = result.replace(negativeRegex, (match, content) => {
        return value.length === 0 ? content : '';
      });
    } else {
      // Simple variable replacement
      // Use function replacement to avoid $ being interpreted as special replacement pattern
      const varRegex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
      result = result.replace(varRegex, () => String(value));
    }
  }
  
  return result;
}

/**
 * Gets template for a framework
 * @param {string} framework
 * @returns {string}
 */
export function getTemplate(framework) {
  // Use Object.hasOwn to avoid prototype pollution (e.g., 'toString', 'valueOf')
  if (Object.hasOwn(TEMPLATES, framework)) {
    return TEMPLATES[framework];
  }
  return TEMPLATES.default;
}

/**
 * Merges existing CLAUDE.md content with new content
 * @param {string} existing
 * @param {string} generated
 * @returns {string}
 */
export function mergeClaudeMd(existing, generated) {
  // Parse sections from both
  const existingSections = parseSections(existing);
  const generatedSections = parseSections(generated);
  
  // Merge: keep existing sections, add new ones
  const merged = { ...generatedSections };
  
  for (const [title, content] of Object.entries(existingSections)) {
    if (merged[title]) {
      // Combine content, avoiding duplicates
      // Keep original content (not trimmed) for preservation
      const existingLines = content.split('\n').filter(l => l.trim().length > 0);
      const generatedLines = merged[title].split('\n').filter(l => l.trim().length > 0);
      
      // Use trimmed versions for comparison but keep originals
      const existingTrimmed = new Set(existingLines.map(l => l.trim()));
      
      const combinedLines = [...existingLines];
      for (const line of generatedLines) {
        const trimmed = line.trim();
        if (trimmed.length > 0 && !existingTrimmed.has(trimmed)) {
          combinedLines.push(line);
        }
      }
      
      merged[title] = combinedLines.join('\n');
    } else {
      merged[title] = content;
    }
  }
  
  // Reconstruct document
  let result = '# CLAUDE.md\n\n';
  for (const [title, content] of Object.entries(merged)) {
    if (title !== 'CLAUDE.md') {
      const trimmedContent = content.trim();
      if (trimmedContent.length > 0) {
        result += `## ${title}\n\n${trimmedContent}\n\n`;
      } else {
        result += `## ${title}\n\n`;
      }
    }
  }
  
  return result.trim() + '\n';
}

/**
 * Parses CLAUDE.md into sections
 * @param {string} content
 * @returns {Record<string, string>}
 */
function parseSections(content) {
  const sections = {};
  const lines = content.split('\n');
  let currentSection = '';
  let currentContent = [];
  
  for (const line of lines) {
    if (line.startsWith('## ')) {
      if (currentSection) {
        sections[currentSection] = currentContent.join('\n').trim();
      }
      currentSection = line.slice(3).trim();
      currentContent = [];
    } else if (line.startsWith('# ')) {
      currentSection = line.slice(2).trim();
      currentContent = [];
    } else {
      currentContent.push(line);
    }
  }
  
  if (currentSection) {
    sections[currentSection] = currentContent.join('\n').trim();
  }
  
  return sections;
}

/**
 * Generates CLAUDE.md file
 * @param {GeneratorContext} context
 * @returns {Promise<GeneratorResult>}
 */
export async function generateClaudeMd(context) {
  const { framework, mcps, skills, template } = context;
  const claudeMdPath = path.join(process.cwd(), 'CLAUDE.md');
  
  // Get template
  const templateContent = getTemplate(template || framework);
  
  // Render template
  const rendered = renderTemplate(templateContent, {
    mcps,
    skills,
    framework
  });
  
  // Check if file exists
  let existingContent = null;
  let action = 'created';
  
  try {
    existingContent = await fs.readFile(claudeMdPath, 'utf8');
  } catch (err) {
    if (err.code !== 'ENOENT') throw err;
  }
  
  if (existingContent) {
    action = await promptExistingClaudeMd();
    
    if (action === 'skip') {
      return { generated: false, action: 'skipped' };
    }
    
    if (action === 'merge') {
      const merged = mergeClaudeMd(existingContent, rendered);
      await fs.writeFile(claudeMdPath, merged, 'utf8');
      return { generated: true, action: 'merged' };
    }
  }
  
  // Write file (create or overwrite)
  await fs.writeFile(claudeMdPath, rendered, 'utf8');
  return { generated: true, action: existingContent ? 'overwritten' : 'created' };
}

/**
 * @typedef {Object} GeneratorContext
 * @property {string} framework
 * @property {string[]} mcps
 * @property {string[]} skills
 * @property {string} template
 * @property {string} [existingContent]
 */

/**
 * @typedef {Object} GeneratorResult
 * @property {boolean} generated
 * @property {'created' | 'overwritten' | 'merged' | 'skipped'} action
 */
